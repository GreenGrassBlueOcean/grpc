# SCRIPT FOR R SESSION 2: CLIENT (client-test2.r)
# Purpose: Tests the revised grpc_client R wrapper against the server.

# 0. Load necessary libraries
# library(grpc) # Should be loaded by devtools::load_all(".") before running this script
library(RProtoBuf)
library(futile.logger)

flog.threshold(DEBUG)

# 1. Verify Proto Definitions are available (loaded by .onLoad from grpc package)
flog.info("CLIENT: Verifying proto types are available after package load...")
REQ_DESC_FOR_CLIENT <- NULL
REP_DESC_FOR_CLIENT <- NULL
proto_types_ok_for_client <- FALSE
tryCatch({
  REQ_DESC_FOR_CLIENT <- RProtoBuf::P("helloworld.GreetingRequest")
  REP_DESC_FOR_CLIENT <- RProtoBuf::P("helloworld.GreetingReply")
  if (is(REQ_DESC_FOR_CLIENT, "Descriptor") && is(REP_DESC_FOR_CLIENT, "Descriptor")) {
    flog.info("CLIENT: helloworld.GreetingRequest and helloworld.GreetingReply descriptors found.")
    proto_types_ok_for_client <- TRUE
  } else {
    flog.error("CLIENT: P() did not return valid descriptors after package load.")
  }
}, error = function(e) {
  flog.error("CLIENT: Error retrieving protobuf descriptors: %s", e$message)
})

if (!proto_types_ok_for_client) {
  stop("CLIENT: Protobuf message types not correctly available. Ensure 'grpc' package loaded protos via .onLoad. Halting.")
}

# 2. MANUALLY ENTER THE PORT NUMBER observed from Server Session 1's C++ logs
MANUALLY_ENTERED_PORT <- 56843  # !!! --- REPLACE WITH THE ACTUAL PORT FROM YOUR SERVER LOG --- !!!

if (!is.numeric(MANUALLY_ENTERED_PORT) || is.na(MANUALLY_ENTERED_PORT) || MANUALLY_ENTERED_PORT <= 0 || MANUALLY_ENTERED_PORT > 65535) {
  stop("CLIENT: Invalid MANUALLY_ENTERED_PORT. Please set it to the integer port number from the server's log.")
}
flog.info("CLIENT: Will attempt to connect to port: %d", MANUALLY_ENTERED_PORT)
client_target_address <- paste0("localhost:", MANUALLY_ENTERED_PORT)


# 3. Define the 'services' structure for grpc_client
# This tells grpc_client about the methods, their full paths, and their message types.
# This could eventually be generated by a read_services() function in your package.
client_service_spec <- list(
  SayHello = list( # Key is the simple method name, used for $SayHello
    name = "/helloworld.Greeter/SayHello",       # Fully qualified gRPC method for the call
    RequestType = REQ_DESC_FOR_CLIENT,           # The actual descriptor object
    ResponseType = REP_DESC_FOR_CLIENT           # The actual descriptor object
  )
  # Add other methods here if your service defines them:
  # SayThanks = list(name = "/helloworld.Greeter/SayThanks", RequestType=P(...), ResponseType=P(...)),
  # SayBye = list(name = "/helloworld.Greeter/SayBye", RequestType=P(...), ResponseType=P(...))
)

# 4. Create the client stub using your package's grpc_client function
flog.info("CLIENT: Creating client stub using grpc::grpc_client...")
greeter_client <- NULL
tryCatch({
  greeter_client <- grpc::grpc_client(services = client_service_spec, channel = client_target_address)
  flog.info("CLIENT: Client stub created successfully.")
}, error = function(e) {
  flog.error("CLIENT: Failed to create client stub: %s", e$message)
  stop("Client stub creation failed.")
})

# 5. Prepare the request and expected response
request_name_val <- "R gRPC User via Stub"
expected_r_handler_reply_message <- paste("R says hello to", request_name_val)
client_test_final_status <- FALSE

# 6. Execute the RPC using the client stub
if (!is.null(greeter_client) && !is.null(greeter_client$SayHello)) {
  tryCatch({
    flog.info("CLIENT: Building request message using stub$SayHello$build()...")
    request_message_object <- greeter_client$SayHello$build(name = request_name_val)
    flog.info("CLIENT: Request object built: %s", RProtoBuf::toString(request_message_object))

    flog.info("CLIENT: Calling server using stub$SayHello$call()...")
    # The call() function within the stub will handle:
    # - Serializing request_message_object
    # - Calling robust_grpc_client_call
    # - Deserializing the raw response into a GreetingReply RProtoBuf object
    response_message_object <- greeter_client$SayHello$call(
      request_message_object,
      metadata = list("client-source", "R-stub-test-v2") # Example metadata
    )

    flog.info("CLIENT: Received and deserialized response. Message content: '%s'", response_message_object$message)

    if (response_message_object$message == expected_r_handler_reply_message) {
      flog.info("CLIENT: SUCCESS! Received expected reply from the R handler via client stub.")
      client_test_final_status <- TRUE
    } else {
      flog.error("CLIENT: FAILED! Reply mismatch from R handler via stub. Expected: '%s', Got: '%s'",
                 expected_r_handler_reply_message, response_message_object$message)
    }

  }, error = function(e) {
    flog.error("CLIENT: An error occurred during the stub call: %s", e$message)
    flog.info("CLIENT: Ensure the server (Session 1) is still running and listening on port %d.", MANUALLY_ENTERED_PORT)
    flog.info("CLIENT: The server is expected to run for %d seconds.", 600) # Match server script
  })
} else {
  flog.error("CLIENT: greeter_client stub or $SayHello method not found. Check grpc_client() setup.")
}

# 7. Report Final Test Outcome
if (client_test_final_status) {
  flog.info(">>>> Client Test (using grpc_client stub): PASSED <<<<")
} else {
  flog.error(">>>> Client Test (using grpc_client stub): FAILED <<<<")
}
