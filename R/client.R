#' Build a gRPC client stub
#'
#' Creates a list of functions that can be used to call methods on a gRPC service.
#'
#' @param services A list describing the service methods. Typically generated by
#'   a function like \code{read_services()}. Each element of the list should
#'   correspond to a gRPC method. The name of the list element should be the
#'   simple method name (e.g., "SayHello"). Each element itself should be a list
#'   containing:
#'   \itemize{
#'     \item \code{name}: The fully qualified gRPC method string (e.g., "/package.Service/MethodName").
#'     \item \code{RequestType}: The \code{RProtoBuf::Descriptor} object for the request message type.
#'     \item \code{ResponseType}: The \code{RProtoBuf::Descriptor} object for the response message type.
#'   }
#' @param channel A string specifying the server address and port (e.g., "localhost:50051").
#' @return A list where names correspond to the simple service method names.
#'   Each element is itself a list with two functions:
#'   \itemize{
#'     \item \code{build(...)}: A function to construct a new request message object of the
#'           correct type for that method. Arguments are passed to \code{RProtoBuf::new()}.
#'     \item \code{call(request_message, metadata = list())}: A function to execute the RPC.
#'           It takes the RProtoBuf request message object and an optional named R list for metadata.
#'           It returns the deserialized RProtoBuf response message object.
#'   }
#' @importFrom RProtoBuf serialize read new P
#' @importFrom methods is
#' @importFrom futile.logger flog.debug flog.warn
#' @export
grpc_client <- function(services, channel) {
  if (!is.list(services)) {
    stop("'services' must be a list (e.g., from read_services).")
  }
  if (!is.character(channel) || length(channel) != 1 || !nzchar(channel)) {
    stop("'channel' must be a non-empty single string (e.g., 'localhost:50051').")
  }

  client_stubs <- lapply(names(services), function(simple_method_name) {
    method_spec <- services[[simple_method_name]]

    # Validate the method specification structure
    if (!is.list(method_spec) ||
        is.null(method_spec$RequestType) ||
        is.null(method_spec$ResponseType) ||
        is.null(method_spec$name) || !is.character(method_spec$name) || !nzchar(method_spec$name)) {
      stop(paste("Service specification for method '", simple_method_name, "' is invalid or missing fields (name, RequestType, ResponseType)."))
    }

    req_descriptor <- method_spec$RequestType
    res_descriptor <- method_spec$ResponseType
    full_method_path <- method_spec$name

    # Validate descriptors
    if (!is(req_descriptor, "Descriptor")) {
      stop(paste("Invalid RequestType for method '", simple_method_name, "'. Expected RProtoBuf 'Descriptor' object."))
    }
    if (!is(res_descriptor, "Descriptor")) {
      stop(paste("Invalid ResponseType for method '", simple_method_name, "'. Expected RProtoBuf 'Descriptor' object."))
    }

    list(
      build = function(...) {
        # Creates an RProtoBuf message object for the request
        RProtoBuf::new(req_descriptor, ...)
      },
      call = function(request_message, metadata = list()) {
        if (!is(request_message, "Message") || !identical(RProtoBuf::descriptor(request_message), req_descriptor)) {
          stop(paste0("Argument 'request_message' for method '", simple_method_name,
                      "' is not a valid RProtoBuf Message of the expected type (",
                      RProtoBuf::name(req_descriptor), "). Use the '$build()' function to create it."))
        }

        serialized_request <- RProtoBuf::serialize(request_message, NULL)

        # Call the C++ function (ensure it's robust_grpc_client_call or its RcppExport wrapper)
        # The Rcpp wrapper robust_grpc_client_call handles the SEXP r_metadata_sexp.
        serialized_response <- robust_grpc_client_call(
          r_target_str = channel,
          r_method_str = full_method_path,
          r_request_payload = serialized_request,
          r_metadata_sexp = metadata # Pass the R list directly; C++ expects SEXP or Rcpp::List
        )

        if (is.null(serialized_response)) {
          # This case should ideally be handled by robust_grpc_client_call throwing an error
          # if the RPC truly failed at the C++ level (e.g., connection error, non-OK status).
          # If it can return NULL for a "successful" RPC with an empty body (rare for unary),
          # then create an empty response message.
          flog.warn("Received NULL response payload for method '%s'. Returning empty response message.", simple_method_name)
          return(RProtoBuf::new(res_descriptor))
        }
        if (length(serialized_response) == 0) {
          flog.debug("Received empty (zero-length) response payload for method '%s'. Interpreting as empty message.", simple_method_name)
          return(RProtoBuf::new(res_descriptor)) # Create an empty message of the expected type
        }

        # Deserialize the response
        RProtoBuf::read(res_descriptor, serialized_response)
      }
    )
  })

  names(client_stubs) <- names(services) # Set the names of the stubs to simple method names
  return(client_stubs)
}

