% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ProtoParser.R
\name{ProtoParser}
\alias{ProtoParser}
\title{ProtoParser Class for gRPC Services}
\description{
An R6 class to parse `.proto` files, compile them using \code{RProtoBuf},
and extract gRPC service definitions.
}
\details{
This class provides a two-step process for handling `.proto` files. First,
the `$compile()` method invokes `RProtoBuf` to load the protocol buffer
message definitions into the R session. This makes message descriptors
available. Second, the `$parse()` method reads the text of the same `.proto`
file to identify `service` and `rpc` definitions, linking them to the
compiled message descriptors.

This two-step approach is necessary because `RProtoBuf` compiles and loads
message types but does not expose service definitions in an easily
accessible R structure. This parser bridges that gap.
}
\examples{
\dontrun{
# Helper function to create a temporary .proto file for the example
create_temp_proto <- function(content) {
  proto_file <- tempfile(fileext = ".proto")
  writeLines(text = content, con = proto_file)
  return(proto_file)
}

# 1. Define proto content with a package, service, and an RPC
proto_content <- '
syntax = "proto3";

package helloworld;

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}
'

proto_file <- create_temp_proto(proto_content)

# 2. Create a new parser instance
# This only checks for file existence
parser <- ProtoParser$new(proto_file)

# 3. Compile the proto file and then parse it
# Method chaining is supported
parser$compile()$parse()

# 4. Retrieve the parsed service definitions
services <- parser$get_services()

# 5. Inspect the result
print(services)

# Expected output structure:
# $SayHello
# $SayHello$name
# [1] "/helloworld.Greeter/SayHello"
#
# $SayHello$RequestType
# RProtoBuf Descriptor for message helloworld.HelloRequest
#
# $SayHello$ResponseType
# RProtoBuf Descriptor for message helloworld.HelloReply
# ... and other fields

# Clean up the temporary file
unlink(proto_file)
}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ProtoParser-new}{\code{ProtoParser$new()}}
\item \href{#method-ProtoParser-compile}{\code{ProtoParser$compile()}}
\item \href{#method-ProtoParser-parse}{\code{ProtoParser$parse()}}
\item \href{#method-ProtoParser-get_services}{\code{ProtoParser$get_services()}}
\item \href{#method-ProtoParser-clone}{\code{ProtoParser$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProtoParser-new"></a>}}
\if{latex}{\out{\hypertarget{method-ProtoParser-new}{}}}
\subsection{Method \code{new()}}{
Creates a new `ProtoParser` object.

This step is lazy and does not read or process the file until `$compile()`
or `$parse()` are called. It only checks for the file's existence and
performs initial tokenization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ProtoParser$new(file, logger = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{A string, the path to the `.proto` file.}

\item{\code{logger}}{An optional logger object (e.g., from the 'lgr' package)
for logging messages. If `NULL`, a default `GrpcLogger` is used.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new `ProtoParser` object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProtoParser-compile"></a>}}
\if{latex}{\out{\hypertarget{method-ProtoParser-compile}{}}}
\subsection{Method \code{compile()}}{
Compiles the `.proto` file using `RProtoBuf::readProtoFiles`.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ProtoParser$compile()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method is a prerequisite for `$parse()`. It temporarily changes the
working directory to the directory containing the `.proto` file, which
is the most robust way to handle imports within `.proto` files for
`RProtoBuf`. The original working directory is restored upon completion,
even if an error occurs.
}

\subsection{Returns}{
The `ProtoParser` object, invisibly, to allow for chaining
  (e.g., `parser$compile()$parse()`).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProtoParser-parse"></a>}}
\if{latex}{\out{\hypertarget{method-ProtoParser-parse}{}}}
\subsection{Method \code{parse()}}{
Parses the tokenized `.proto` file to extract service definitions.

This method must be called after `$compile()`. It scans the file for
`package`, `service`, and `rpc` declarations to build an internal
representation of the services. It will overwrite any previously
parsed services.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ProtoParser$parse()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The `ProtoParser` object, invisibly, to allow for chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProtoParser-get_services"></a>}}
\if{latex}{\out{\hypertarget{method-ProtoParser-get_services}{}}}
\subsection{Method \code{get_services()}}{
Retrieves the parsed gRPC service definitions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ProtoParser$get_services()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A named list where each element corresponds to an RPC method.
  The name of the element is the simple RPC name (e.g., "SayHello").
  Each element is a list containing:
  \itemize{
    \item \code{name}: The full RPC path (e.g., "/package.Service/RpcName").
    \item \code{f}: An identity function placeholder.
    \item \code{client_streaming}: A logical, `TRUE` if the client sends a stream.
    \item \code{server_streaming}: A logical, `TRUE` if the server returns a stream.
    \item \code{RequestType}: The `RProtoBuf::Descriptor` for the request message.
    \item \code{RequestTypeName}: The fully qualified name of the request message.
    \item \code{ResponseType}: The `RProtoBuf::Descriptor` for the response message.
    \item \code{ResponseTypeName}: The fully qualified name of the response message.
  }
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProtoParser-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ProtoParser-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ProtoParser$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
